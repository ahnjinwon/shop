# List / Set / Map 의 메모리 상태

아래 설명은 “메모리에서 값을 어떻게 가져오는지”를 기준으로 정리했습니다.

## List

### ArrayList
- **배열처럼 붙어 있음**  
  - 값들이 연속된 메모리 공간에 순서대로 붙어 있어 인덱스로 바로 접근합니다.
- **가져올 때**  
  - `array[start + index * 요소크기]` 방식으로 바로 값을 읽어 온다.
- **삽입/삭제**  
  - 중간에 넣거나 빼면 뒤쪽 요소를 한 칸씩 이동시켜야 한다.

### LinkedList
- **노드 + 포인터 구조**  
  - 각 노드가 값과 다음 노드를 가리키는 포인터를 가진다.
- **가져올 때**  
  - 첫 노드부터 하나씩 따라가며 원하는 위치까지 이동해야 하므로 ArrayList보다 느리다.
- **삽입/삭제**  
  - 노드 포인터만 맞바꾸면 되기 때문에 위치를 알고 있다면 빠르다.

## Set (HashSet 기준)

- **해시 버킷 배열 + Node 구조**  
  - 값의 해시를 계산해 버킷 배열의 특정 인덱스를 찾습니다.  
  - 버킷 안에는 Node(값, 해시, 다음 노드 포인터)가 연결 리스트 형태로 저장됩니다.
- **가져올 때**  
  1. 찾으려는 값의 해시를 계산합니다.  
  2. 해당 해시에 해당하는 버킷을 찾아갑니다(배열 인덱스 접근).  
  3. 그 버킷 안의 Node들을 하나씩 확인하며 같은 값인지 비교합니다.  
  4. 찾으면 Node가 들고 있는 값을 반환합니다.
- **메모리에서의 모습**  
  ```
  bucket0 -> node(valueA) -> node(valueB)
  bucket1 -> node(valueC)
  bucket2 -> null
  ```
  - 버킷 배열은 연속되어 있지만, Node들은 힙 메모리 여기저기에 놓여 있고 포인터로 연결되어 있습니다.
- **특징**  
  - 중복 없이 저장하려면 Node마다 해시/포인터를 추가로 기록해야 하므로 List보다 약간 더 많은 메모리를 사용합니다.  
  - 단, 해시 계산만 잘 되면 값 존재 여부를 평균적으로 빠르게 확인할 수 있습니다.
  - 해시가 우연히 많이 충돌하면 한 버킷 안을 처음부터 끝까지 훑어야 해서 느려질 수 있습니다.  
  - 이런 최악의 상황을 줄이기 위해 해시 테이블은 버킷 수를 늘리고 재해싱을 통해 충돌을 분산시키도록 설계되어 있습니다.

## Map (HashMap 기준)

- **키와 값의 쌍**  
  - Set과 비슷하지만 Node가 `key`, `value`, 해시, 다음 노드 포인터를 모두 가지고 있습니다.
- **가져올 때**  
  1. 찾으려는 키의 해시를 계산한다.  
  2. 해당 버킷으로 이동해 Node 리스트를 훑는다.  
  3. 키가 같으면 그 Node 안에 있는 값을 반환한다.
- **메모리에서의 모습**  
  ```
  bucket0 -> node(keyA, valueX) -> node(keyB, valueY)
  bucket1 -> node(keyC, valueZ)
  ```
  - 하나의 Node가 키와 값을 모두 들고 있어 Set보다 더 많은 정보를 저장합니다.
- **특징**  
  - 키로 값을 빠르게 찾을 수 있지만, 키/값/포인터가 모두 메모리에 있어 List나 Set보다 공간을 더 씁니다.

## 정리
- **List**: 연속된 배열처럼 저장되어 “인덱스로 찾기”가 가장 빠르고 단순하다.
- **Set**: 값을 해시 버킷에서 찾아 중복 여부나 존재 여부를 빠르게 확인할 수 있다.
- **Map**: 키와 값을 함께 저장하지만, 키를 해시로 찾으므로 평균적으로 매우 빠른 조회가 가능하다.
